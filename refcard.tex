\documentclass{article}
\usepackage[a4paper,landscape,margin=5mm]{geometry}
\usepackage[french]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage[fontsize=6.5pt]{scrextend}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{tabularx,booktabs}
\usepackage{graphicx}
\usepackage{stix}
\usepackage{listings}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{tikz-uml}
\usepackage{makecell}

\input{revision}

\setcellgapes{3pt}
\let\oldmakecell\makecell
\renewcommand\makecell[2][cc]{\renewcommand\cellalign{#1}\oldmakecell{#2}}
\tikzumlset{
    fill class=white,
    fill template=white,
    fill package=white,
    fill note=white
}

\sloppy
\hyphenpenalty 10000000

\ifdefined\tinted
  \pagecolor{Lavender!60}
\fi


\setlength{\parskip}{0.2em}
\setlength{\parindent}{0em}

% Highlight configuration for C++ programming language
\lstset{
  language=C++,
  breaklines=true,
  keywordstyle=\bfseries\color{black},
  basicstyle=\ttfamily\color{black},
  emphstyle={\em \color{gray}},
  emph={expr, type, NAME, ptr, name, expr, value, filename, label, member, type},
  mathescape=true,
  keepspaces=true,
  showspaces=false,
  showtabs=true,
  tabsize=3,
  columns=fullflexible,
  escapeinside={(*}{*)}
}

% Configuration
\renewcommand{\familydefault}{\sfdefault}

\setmonofont{Source Code Pro}

% No pages numbering
\pagenumbering{gobble}

% Titles and paragraphs more compact
\titlespacing*{\section}{0pt}{0pt}{0pt}
\titlespacing*{\subsection}{0pt}{0pt}{0pt}

\newlength\mybaselinestretch
\mybaselinestretch=0pt plus 0.02pt\relax
\addtolength{\baselineskip}{\mybaselinestretch}

\setlength\parindent{0pt}
\setlength\tabcolsep{1.5pt}
\setlength{\columnseprule}{0.4pt}

% Macros
\newcommand{\tab}{\hspace{2em}}
\newcommand{\etc}{\small \ldots}
\newcommand{\any}{$\hzigzag$~}
\newcommand{\spc}{$\mathvisiblespace$}
\newcommand{\cd}{\lstinline}

\begin{document}

\begin{multicols*}{3}

  \begin{tabularx}{\columnwidth}{@{}lX}
    \raisebox{-\totalheight}{\includegraphics[width=1cm]{assets/heig-vd-black.pdf}} &
\begin{center}
  {\Large \bf Carte de référence Programmation Objet} \\
  version \revision \ -- \revisiondate \\
\end{center}
\end{tabularx}

Cette carte de référence est une liste non exhaustive du paradigme Objet et de ses notions fondamentales

\vspace{1em}
\hrule

\section*{Niveaux d'abstraction}
\begin{enumerate}
\item \textbf{Objet} : données en mémoire associées à des comportements
\item \textbf{Classe} : modèle de données, structure et comportement
\item \textbf{Héritage} : spécialisation de classes
\item \textbf{Polymorphisme} : comportement générique
\item \textbf{Abstraction} : séparation interface/implémentation
\item \textbf{Encapsulation} : regroupement données et comportements
\end{enumerate}

\section*{S.O.L.I.D.}
\begin{description}%
\item[S] \emph{Responsabilité unique}. Le principe de responsabilité unique stipule qu'une classe ne devrait avoir qu'\textbf{une seule raison de changer} et \textbf{une seule responsabilité}.
\item[O] \emph{Ouvert/Fermé}. Une entité applicative doit être fermée à la modification directe mais ouverte à l'extension
\item[L] \emph{Substitution de Liskov}. Une instance de type T doit pouvoir être remplacée par une instance de type G, tel que G sous-type de T, sans rupture de la cohérence du programme
\item[I] \emph{Ségrégation des interfaces}. Préférer plusieurs interfaces spécifiques pour chaque client plutôt qu'une seule interface générale
\item[D] \emph{Inversion des dépendances}. Il faut dépendre des abstractions, pas des implémentations.
\end{description}

\section*{RAII}
Le principe RAII (\emph{Resource Acquisition Is Initialization}) en C++ consiste à lier la durée de vie des ressources (mémoire, fichiers, connexions réseau, etc.) à la durée de vie des objets. Ainsi, les ressources sont acquises lors de la création de l'objet (dans le constructeur) sont libérées lors de la destruction de l'objet (dans le destructeur).

\begin{lstlisting}[language=C++]
class Resource {
public:
    Resource() { /* Acquisition de la ressource */ }
    ~Resource() { /* Libération de la ressource */ } };
\end{lstlisting}

\section*{Paradigme orienté-objet}
\begin{description}
\item[Objets] Les sont des instances de classes résidentes en mémoire. Ils possèdent un constructeur, un destructeur et véhiculent des données.
\item[Classe] Les classes sont des \emph{Modèles} d'\emph{Objets}. Ils sont définis par des attributs et des méthodes.
\item[Héritage] Les classes peuvent hériter d'une autre classe et ainsi se spécialiser (en respectant le principe de substitution de Liskov).
\item[Polymorphisme] Une classe parente peut être substituée par une classe enfant et ainsi le comportement de l'objet est généralisé.
\item[Abstraction] Offre une abstraction des détails d'implémentation par la description d'interfaces et de comportements.
\item[Encapsulation] Permet de regrouper les données avec des routines qui en permettent la manipulation. Elle permet de modifier des données sans modifier l'interface de celle-ci.
\item[Interface] Contrat définissant un ensemble de méthodes qu'une classe doit implémenter. C'est un contrat.
\item[Classe abstraite] Classe qui ne peut être instanciée, contient au moins une méthode virtuelle pure.
\item[Cohésion] Mesure à quel point les éléments d'une classe collaborent pour une responsabilité unique.
\item[Couplage] Degré d'interdépendance entre les classes (faible couplage souhaitable).
\end{description}

\section*{Héritage v.s. Composition}
Exemple de composition (Has-a) et d'héritage (Is-a):
\begin{lstlisting}[language=C++]
class Moteur {
public:
    void demarrer() { /* ... */ }
    void arreter() { /* ... */ }
};
class Voiture {
private:
    Moteur moteur; // Composition: Voiture a un Moteur
public:
    void demarrer() { moteur.demarrer(); }
    void arreter() { moteur.arreter(); }
};

class Vehicule {
public:
    virtual void demarrer() = 0;
    virtual void arreter() = 0;
};
class Moto : public Vehicule { // Héritage: Moto est un Vehicule
public:
    void demarrer() override { /* ... */ }
    void arreter() override { /* ... */ }
};
\end{lstlisting}
\section*{Modificateurs d'accès}
\begin{description}
\item[public] Accessible depuis l'extérieur de la classe \\
\item[private] Accessible uniquement depuis la classe elle-même \\
\item[protected] Accessible depuis la classe et ses classes dérivées
\end{description}

\section*{Méthodes et concepts spéciaux}
\begin{description}
\item[Constructeur] Initialise un objet lors de sa création
\item[Destructeur] Nettoie les ressources lors de la destruction (\texttt{\textasciitilde{}})
\item[virtual] Permet le polymorphisme dynamique
\item[= 0] Méthode virtuelle pure (classe abstraite)
\item[override] Indique qu'une méthode redéfinit une méthode virtuelle
\item[final] Empêche la redéfinition d'une méthode ou l'héritage d'une classe
\item[const] Méthode qui ne modifie pas l'état de l'objet
\item[static] Méthode/attribut appartenant à la classe, pas à l'instance
\item[friend] Permet l'accès aux membres privés depuis l'extérieur
\item[Surcharge] Plusieurs méthodes avec le même nom mais paramètres différents
\item[Templates] Généricité permettant de créer des classes/fonctions paramétrées
\end{description}

\section*{Types de polymorphisme}
\begin{description}
\item[Adhoc] Surcharge d'opérateurs et de fonctions
\item[Paramétré] Templates et généricité
\item[Inclusion] Héritage et méthodes virtuelles
\item[Liaison statique] Résolution à la compilation
\item[Liaison dynamique] Résolution à l'exécution (vtable)
\item[Covariance] Type de retour plus spécifique dans classe dérivée
\item[Contravariance] Paramètre plus général dans classe dérivée
\end{description}

\section*{Interface}
\begin{lstlisting}[language=C++]
class IAnimal { // Interface pure
public:
    virtual ~IAnimal() = default;
    virtual void crier() const = 0;
    virtual void manger() = 0;
};

class Animal : public IAnimal { // Classe abstraite
    string nom;
protected:
    int age;
public:
    Animal(string n) : nom(n), age(0) {}
    virtual ~Animal() {}
    string getNom() const { return nom; }
    friend ostream& operator<<(ostream& os, const Animal& a);
};

class Chat : public Animal {
public:
    Chat(string n) : Animal(n) {}
    void crier() const override { cout << "Miaou"; }
    void manger() override { cout << "Croquettes"; }
};
\end{lstlisting}

\subsection*{Template de classe}
\begin{lstlisting}[language=C++]
template<typename T>
class Container {
private:
    vector<T> items;
public:
    void add(const T& item) { items.push_back(item); }
    T& get(size_t index) { return items[index]; }
    template<typename U>
    void addConverted(const U& item) { 
        items.push_back(static_cast<T>(item)); 
    }
};
// Usage: Container<int> intContainer;
\end{lstlisting}

\subsection*{Factory Pattern}
\begin{lstlisting}[language=C++]
class AnimalFactory {
public:
    static unique_ptr<Animal> create(const string& type) {
        if (type == "chat") return make_unique<Chat>();
        if (type == "chien") return make_unique<Chien>();
        return nullptr;
    }
};

% class Chat : public Animal {
% public:
%     Chat(string n) : Animal(n) {}
%     void crier() const override { cout << "Miaou"; }
%     void manger() override { cout << "Croquettes"; }
% };
% \end{lstlisting}

\section*{Relations UML}
\begin{tabularx}{\columnwidth}{lX}
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umldep{A}{B}
\end{tikzpicture} & Dépendence \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlassoc{A}{B}
\end{tikzpicture} & Association \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umluniassoc{A}{B}
\end{tikzpicture} & Association Unique \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlaggreg{A}{B}
\end{tikzpicture} & Aggrégation. La classe A contient une collection de B. Lorsque A est détruite les instances de B ne sont pas détruites. \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlcompo{A}{B}
\end{tikzpicture} & Composition. La classe A contient une collection de B. Lorsque A est détruite les instances de B sont également détruites. \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlinherit{A}{B}
\end{tikzpicture} & Héritage. La classe A hérite de B. On dit que A et un B.\\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlimpl{A}{B}
\end{tikzpicture} & Implémentation/Réalisation \\
\end{tabularx}

\section*{Gestion d'erreurs OOP}
\begin{description}
\item[Exception] Objet lancé en cas d'erreur, interrompt l'exécution normale
\item[try-catch] Bloc de gestion des exceptions
\item[throw] Lance une exception
\item[std::exception] Classe de base pour les exceptions standard
\item[Exception safety] Garanties sur l'état des objets en cas d'exception
\end{description}

\section*{Principes modernes}
\begin{description}
\item[RAII] Resource Acquisition Is Initialization - acquérir les ressources dans le constructeur, les libérer dans le destructeur
\item[Rule of 3/5/0] Si une classe définit destructeur, constructeur de copie ou opérateur d'assignation, elle doit probablement définir les trois (ou cinq avec move)
\item[Has-a vs Is-a] Composition (Has-a) souvent préférable à l'héritage (Is-a) pour la flexibilité
\item[Smart pointers] \texttt{unique\_ptr}, \texttt{shared\_ptr}, \texttt{weak\_ptr} pour la gestion automatique de la mémoire
\item[Move semantics] Optimisation des transferts de ressources (C++11)
\item[auto] Déduction automatique de type
\item[Lambda] Fonctions anonymes et closures
\item[Range-based for] Itération simplifiée sur conteneurs
\item[Concepts] Contraintes sur les templates (C++20)
\item[Modules] Nouvelle unité de compilation (C++20)
\item[Constexpr] Évaluation à la compilation
\item[RTTI] Run-Time Type Information
\end{description}

\section*{Généricité et Templates}
\begin{description}
\item[Template de classe] Classe paramétrée par types
\item[Template de fonction] Fonction générique
\item[Spécialisation] Version spécifique pour certains types
\item[SFINAE] Substitution Failure Is Not An Error
\item[Type traits] Métaprogrammation sur les types
\item[Variadic templates] Nombre variable de paramètres
\item[Perfect forwarding] Préservation de la catégorie de valeur
\item[Java Generics] \texttt{List<T>}, effacement de type
\item[C\# Generics] Génériques avec réification
\item[Python Generics] \texttt{List[T]}, typing hints
\end{description}

\section*{Design Patterns essentiels}
\begin{description}
\item[Singleton] Une seule instance de classe, accès global contrôlé
\item[Factory] Création d'objets sans exposer la logique d'instanciation
\item[Abstract Factory] Familles d'objets liés sans spécifier leurs classes
\item[Builder] Construction étape par étape d'objets complexes
\item[Prototype] Clonage d'objets existants
\item[Observer] Notification automatique des changements d'état
\item[Strategy] Encapsule des algorithmes et permet leur interchangeabilité
\item[Template Method] Définit le squelette d'un algorithme, sous-classes implémentent les étapes
\item[Decorator] Attache dynamiquement des responsabilités supplémentaires
\item[Command] Encapsule une requête comme un objet
\item[Adapter] Permet à des classes incompatibles de collaborer
\item[Facade] Interface simplifiée pour un sous-système complexe
\item[Proxy] Contrôle l'accès à un autre objet
\item[Chain of Responsibility] Chaîne de gestionnaires pour traiter les requêtes
\item[State] Modifie le comportement selon l'état interne
\item[Visitor] Sépare algorithmes et structure d'objets
\end{description}

\subsection*{Observer}
\begin{lstlisting}[language=C++]
struct IObserver {
    virtual void update() = 0; };
class Subject {
    vector<IObserver*> observers;
  public:
    void attach(IObserver* obs) { observers.push_back(obs); }
    void notify() { for (auto obs : observers) obs->update(); }
};
class ConcreteObserver : public IObserver {
    void update() override { /* ... */ } };
\end{lstlisting}

\subsection*{Strategy}
\begin{lstlisting}[language=C++]
struct IStrategy {
    virtual void execute() = 0; };
struct ConcreteStrategyA : public IStrategy {
    void execute() override { /* ... */ } };
struct ConcreteStrategyB : public IStrategy {
    void execute() override { /* ... */ } };
class Context {
    IStrategy* strategy;
  public:
    void setStrategy(IStrategy* s) { strategy = s; }
    void perform() { strategy->execute(); } };
\end{lstlisting}

\section*{Concepts avancés}
\begin{description}
\item[Inversion de contrôle] Le contrôle est transféré à un framework externe
\item[Injection de dépendance] Fourniture des dépendances depuis l'extérieur
\item[Composition over inheritance] Préférer la composition à l'héritage
\item[Law of Demeter] Un objet ne devrait communiquer qu'avec ses "amis" immédiats
\item[GRASP] Guidelines pour l'attribution des responsabilités (General Responsibility Assignment Software Patterns)
\item[Tell don't ask] Dire aux objets ce qu'ils doivent faire plutôt que demander leur état
\end{description}

\section*{Gestion mémoire multi-langages}
\begin{description}
\item[C++] Gestion manuelle + smart pointers, destructeurs automatiques
\item[Java/C\#] Garbage collection automatique, finalizers optionnels
\item[Python] Reference counting + cycle detection, \texttt{\_\_del\_\_}
\item[Rust] Ownership system, borrow checker, drop traits
\item[Stack vs Heap] Variables locales vs objets dynamiques
\item[Memory leaks] Références circulaires, oubli de libération
\end{description}

\section*{Syntaxe cross-language}
\begin{description}
\item[Classe C++] \texttt{class MyClass \{ public: void method(); \};}
\item[Classe Java] \texttt{public class MyClass \{ public void method() \{\} \}}
\item[Classe C\#] \texttt{public class MyClass \{ public void Method() \{\} \}}
\item[Classe Python] \texttt{class MyClass: def method(self): pass}
\item[Héritage C++] \texttt{class Child : public Parent}
\item[Héritage Java] \texttt{class Child extends Parent}
\item[Interface Java] \texttt{interface IMyInterface \{ void method(); \}}
\item[Abstract C\#] \texttt{abstract class MyClass \{ abstract void Method(); \}}
\end{description}

\section*{Test et qualité OOP}
\begin{description}
\item[Unit testing] Test d'une classe ou méthode isolée
\item[Mock objects] Objets simulés pour isoler les tests
\item[Test fixtures] Environnement de test standardisé
\item[TDD] Test-Driven Development - écrire les tests avant le code
\item[BDD] Behavior-Driven Development - spécifications comportementales
\item[Refactoring] Amélioration du code sans changer le comportement
\item[Code coverage] Mesure du pourcentage de code testé
\item[Integration testing] Tests d'interaction entre classes
\end{description}

\section*{Patterns architecturaux}
\begin{description}
\item[MVC] Model-View-Controller - séparation données/présentation/logique
\item[MVP] Model-View-Presenter - contrôleur plus actif
\item[MVVM] Model-View-ViewModel - binding bidirectionnel
\item[Repository] Encapsule logique d'accès aux données
\item[Unit of Work] Groupe d'opérations transactionnelles
\item[Service Layer] Couche de services métier
\item[Domain Model] Objets métier avec logique intégrée
\item[Active Record] Objet = enregistrement base de données
\end{description}

\section*{OOP et programmation fonctionnelle}
\begin{description}
\item[Immutabilité] Objets non modifiables après création
\item[Pure functions] Méthodes sans effets de bord
\item[Higher-order functions] Fonctions comme paramètres/retour
\item[Monads] Encapsulation de calculs avec contexte
\item[Functors] Objets applicables comme fonctions
\item[Lambda expressions] Fonctions anonymes en OOP
\item[Stream API] Traitement fonctionnel de collections
\end{description}

\section*{Concurrence et OOP}
\begin{description}
\item[Thread safety] Protection contre accès concurrent
\item[Immutable objects] Objets sûrs par design
\item[Monitor pattern] Synchronisation au niveau objet
\item[Producer-Consumer] Pattern de communication entre threads
\item[Actor model] Objets communiquant par messages
\item[Lock-free] Structures sans verrous explicites
\item[Atomic operations] Opérations indivisibles
\end{description}

\section*{Anti-patterns et erreurs courantes}
\begin{description}
\item[God Object] Classe qui fait trop de choses
\item[Anemic Domain Model] Objets sans logique métier
\item[Circular Dependencies] Dépendances circulaires entre classes
\item[Inappropriate Intimacy] Classes trop couplées
\item[Feature Envy] Méthode utilisant plus une autre classe
\item[Data Class] Classe contenant seulement des données
\item[Large Class] Classe avec trop de responsabilités
\item[Long Parameter List] Trop de paramètres dans les méthodes
\item[Duplicate Code] Code répété dans plusieurs classes
\item[Dead Code] Code non utilisé mais maintenu
\end{description}

\section*{SFINAE}
SFINAE (Substitution Failure Is Not An Error) est un principe en C++ qui permet de sélectionner des surcharges de fonctions ou des spécialisations de templates en fonction de la validité des types substitués. Si la substitution d'un type dans une expression de template échoue, cela n'est pas considéré comme une erreur de compilation, mais plutôt comme une indication que cette surcharge ou spécialisation n'est pas applicable. Cela permet de créer des fonctions ou des classes génériques qui s'adaptent automatiquement aux types fournis, en excluant les options non valides.

\begin{lstlisting}[language=C++]
template<typename T>
typename enable_if<is_integral<T>::value, T>::type
process(T value) { return value * 2; }

template<typename T>
typename enable_if<is_floating_point<T>::value, T>::type
process(T value) { return value / 2.0; }
\end{lstlisting}

\section*{CRTP}
Le CRTP (Curiously Recurring Template Pattern) est un idiome de programmation en C++ qui utilise des templates pour permettre à une classe dérivée de référencer sa propre classe de base.

\begin{lstlisting}[language=C++]
template <typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
    void implementation() { /* Comportement par défaut */ }
};
class Derived : public Base<Derived> {
public:
    void implementation() { /* Comportement spécifique */ }
};
\end{lstlisting}

\section*{PIMPLE}
Le pattern PIMPLE (Private Implementation) est une technique de conception en C++ qui consiste à séparer l'interface publique d'une classe de son implémentation privée.

\begin{lstlisting}[language=C++]
// Fichier .h
class MyClass {
  class Impl; // Déclaration anticipée de la classe d'implémentation
  Impl* pImpl; // Pointeur vers l'implémentation privée
public:
  void publicMethod();
};
// Fichier .cpp
class MyClass::Impl {
public:
  void privateMethod() { /* ... */ }
};
void MyClass::publicMethod() {
  pImpl->privateMethod(); // Utilisation de la méthode privée
}
\end{lstlisting}

% \section*{Modèle de classes}
% \begin{center}
% \resizebox{\columnwidth}{!}{%
% \begin{tikzpicture}
% \begin{umlpackage}{p}
% \begin{umlpackage}{sp1}
% \umlclass[template=T]{A}{
%   n : uint \\ t : float
% }{}
% \umlclass[y=-3]{B}{
%   d : double
% }{
%   \umlvirt{setB(b : B) : void} \\ getB() : B}
% \end{umlpackage}
% \begin{umlpackage}[x=10,y=-6]{sp2}
% \umlinterface{C}{
%   n : uint \\ s : string
% }{}
% \end{umlpackage}
% \umlclass[x=2,y=-10]{D}{
%   n : uint
%   }{}
% \end{umlpackage}

% \umlassoc[geometry=-|-, arg1=tata, mult1=*, pos1=0.3, arg2=toto, mult2=1, pos2=2.9, align2=left]{C}{B}
% \umlunicompo[geometry=-|, arg=titi, mult=*, pos=1.7, stereo=vector]{D}{C}
% \umlimport[geometry=|-, anchors=90 and 50, name=import]{sp2}{sp1}
% \umlaggreg[arg=tutu, mult=1, pos=0.8, angle1=30, angle2=60, loopsize=2cm]{D}{D}
% \umlinherit[geometry=-|]{D}{B}
% \umlnote[x=2.5,y=-6, width=3cm]{B}{Je suis une note qui concerne la classe B}
% \umlnote[x=7.5,y=-2]{import-2}{Je suis une note qui concerne la relation d'import}
% \end{tikzpicture}
% }
% \end{center}

\end{multicols*}
\end{document}

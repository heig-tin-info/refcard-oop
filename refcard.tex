\documentclass{article}
\usepackage[a4paper,landscape,margin=5mm]{geometry}
\usepackage[french]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage[fontsize=6.5pt]{scrextend}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{tabularx,booktabs}
\usepackage{graphicx}
\usepackage{stix}
\usepackage{listings}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{tikz-uml}
\usepackage{makecell}

\input{revision}

\setcellgapes{3pt}
\let\oldmakecell\makecell
\renewcommand\makecell[2][cc]{\renewcommand\cellalign{#1}\oldmakecell{#2}}
\tikzumlset{
    fill class=white,
    fill template=white,
    fill package=white,
    fill note=white
}

\sloppy
\hyphenpenalty 10000000

\ifdefined\tinted
  \pagecolor{Lavender!60}
\fi


\setlength{\parskip}{0.2em}
\setlength{\parindent}{0em}

% Highlight configuration for C++ programming language
\lstset{
  language=C++,
  breaklines=true,
  keywordstyle=\bfseries\color{black},
  basicstyle=\ttfamily\color{black},
  emphstyle={\em \color{gray}},
  emph={expr, type, NAME, ptr, name, expr, value, filename, label, member, type},
  mathescape=true,
  keepspaces=true,
  showspaces=false,
  showtabs=true,
  tabsize=3,
  columns=fullflexible,
  escapeinside={(*}{*)}
}

% Configuration
\renewcommand{\familydefault}{\sfdefault}

\setmonofont{Source Code Pro}

% No pages numbering
\pagenumbering{gobble}

% Titles and paragraphs more compact
\titlespacing*{\section}{0pt}{0pt}{0pt}
\titlespacing*{\subsection}{0pt}{0pt}{0pt}

\newlength\mybaselinestretch
\mybaselinestretch=0pt plus 0.02pt\relax
\addtolength{\baselineskip}{\mybaselinestretch}

\setlength\parindent{0pt}
\setlength\tabcolsep{1.5pt}
\setlength{\columnseprule}{0.4pt}

% Macros
\newcommand{\tab}{\hspace{2em}}
\newcommand{\etc}{\small \ldots}
\newcommand{\any}{$\hzigzag$~}
\newcommand{\spc}{$\mathvisiblespace$}
\newcommand{\cd}{\lstinline}

\begin{document}

\begin{multicols*}{3}

  \begin{tabularx}{\columnwidth}{@{}lX}
    \raisebox{-\totalheight}{\includegraphics[width=1cm]{assets/heig-vd-black.pdf}} &
\begin{center}
  {\Large \bf Carte de référence Programmation Objet} \\
  version \revision \ -- \revisiondate \\
\end{center}
\end{tabularx}

Cette carte de référence est une liste non exhaustive du paradigme Objet et de ses notions fondamentales

\hrule

\section*{S.O.L.I.D.}
\begin{description}%
\item[S] \emph{Responsabilité unique}. Le principe de responsabilité unique stipule qu'une classe ne devrait avoir qu'\textbf{une seule raison de changer} et \textbf{une seule responsabilité}.
\item[O] \emph{Ouvert/Fermé}. Une entité applicative doit être fermée à la modification directe mais ouverte à l'extension
\item[L] \emph{Substitution de Liskov}. Une instance de type T doit pouvoir être remplacée par une instance de type G, tel que G sous-type de T, sans rupture de la cohérence du programme
\item[I] \emph{Ségrégation des interfaces}. Préférer plusieurs interfaces spécifiques pour chaque client plutôt qu'une seule interface générale
\item[D] \emph{Inversion des dépendances}. Il faut dépendre des abstractions, pas des implémentations.
\end{description}

\section*{RAII}
Le principe RAII (\emph{Resource Acquisition Is Initialization}) en C++ consiste à lier la durée de vie des ressources (mémoire, fichiers, connexions réseau, etc.) à la durée de vie des objets. Ainsi, les ressources sont acquises lors de la création de l'objet (dans le constructeur) sont libérées lors de la destruction de l'objet (dans le destructeur).

\begin{lstlisting}[language=C++]
class Resource {
public:
    Resource() { /* Acquisition de la ressource */ }
    ~Resource() { /* Libération de la ressource */ } };
\end{lstlisting}

\section*{Paradigme orienté-objet}
\begin{description}
\item[Objets] Les sont des instances de classes résidentes en mémoire. Ils possèdent un constructeur, un destructeur et véhiculent des données.
\item[Classe] Les classes sont des \emph{Modèles} d'\emph{Objets}. Ils sont définis par des attributs et des méthodes.
\item[Héritage] Les classes peuvent hériter d'une autre classe et ainsi se spécialiser (en respectant le principe de substitution de Liskov).
\item[Polymorphisme] Une classe parente peut être substituée par une classe enfant et ainsi le comportement de l'objet est généralisé.
\item[Abstraction] Offre une abstraction des détails d'implémentation par la description d'interfaces et de comportements.
\item[Encapsulation] Permet de regrouper les données avec des routines qui en permettent la manipulation. Elle permet de modifier des données sans modifier l'interface de celle-ci.
\item[Interface] Contrat définissant un ensemble de méthodes qu'une classe doit implémenter. C'est un contrat.
\item[Classe abstraite] Classe qui ne peut être instanciée, contient au moins une méthode virtuelle pure.
\item[Cohésion] Mesure à quel point les éléments d'une classe collaborent pour une responsabilité unique.
\item[Couplage] Degré d'interdépendance entre les classes (faible couplage souhaitable).
\end{description}

\section*{Héritage v.s. Composition}
Exemple de composition (Has-a) et d'héritage (Is-a):
\begin{lstlisting}[language=C++]
class Moteur {
public:
    void demarrer() { /* ... */ }
    void arreter() { /* ... */ }
};
class Voiture {
private:
    Moteur moteur; // Composition: Voiture a un Moteur
public:
    void demarrer() { moteur.demarrer(); }
    void arreter() { moteur.arreter(); }
};

class Vehicule {
public:
    virtual void demarrer() = 0;
    virtual void arreter() = 0;
};
class Moto : public Vehicule { // Héritage: Moto est un Vehicule
public:
    void demarrer() override { /* ... */ }
    void arreter() override { /* ... */ }
};
\end{lstlisting}
\section*{Modificateurs d'accès}
\begin{description}
\item[public] Accessible depuis l'extérieur de la classe \\
\item[private] Accessible uniquement depuis la classe elle-même \\
\item[protected] Accessible depuis la classe et ses classes dérivées
\end{description}

\section*{Méthodes et concepts spéciaux}
\begin{description}
\item[Constructeur] Initialise un objet lors de sa création
\item[Destructeur] Nettoie les ressources lors de la destruction (\texttt{\textasciitilde{}})
\item[virtual] Permet le polymorphisme dynamique
\item[= 0] Méthode virtuelle pure (classe abstraite)
\item[override] Indique qu'une méthode redéfinit une méthode virtuelle
\item[final] Empêche la redéfinition d'une méthode ou l'héritage d'une classe
\item[const] Méthode qui ne modifie pas l'état de l'objet
\item[static] Méthode/attribut appartenant à la classe, pas à l'instance
\item[friend] Permet l'accès aux membres privés depuis l'extérieur
\item[Surcharge] Plusieurs méthodes avec le même nom mais paramètres différents
\item[Templates] Généricité permettant de créer des classes/fonctions paramétrées
\end{description}

\section*{Types de polymorphisme}
\begin{description}
\item[Adhoc] Surcharge d'opérateurs et de fonctions
\item[Paramétré] Templates et généricité
\item[Inclusion] Héritage et méthodes virtuelles
\item[Liaison statique] Résolution à la compilation
\item[Liaison dynamique] Résolution à l'exécution (vtable)
\item[Covariance] Type de retour plus spécifique dans classe dérivée
\item[Contravariance] Paramètre plus général dans classe dérivée
\end{description}

\section*{Interface}
\begin{lstlisting}[language=C++]
class IAnimal { // Interface pure
public:
    virtual ~IAnimal() = default;
    virtual void crier() const = 0;
    virtual void manger() = 0;
};

class Animal : public IAnimal { // Classe abstraite
    string nom;
protected:
    int age;
public:
    Animal(string n) : nom(n), age(0) {}
    virtual ~Animal() {}
    string getNom() const { return nom; }
    friend ostream& operator<<(ostream& os, const Animal& a);
};
\end{lstlisting}
% // Template de classe
% template<typename T>
% class Container {
% private:
%     vector<T> items;
% public:
%     void add(const T& item) { items.push_back(item); }
%     T& get(size_t index) { return items[index]; }
% };

% class Chat : public Animal {
% public:
%     Chat(string n) : Animal(n) {}
%     void crier() const override { cout << "Miaou"; }
%     void manger() override { cout << "Croquettes"; }
% };
% \end{lstlisting}

\section*{Relations UML}
\begin{tabularx}{\columnwidth}{lX}
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umldep{A}{B}
\end{tikzpicture} & Dépendence \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlassoc{A}{B}
\end{tikzpicture} & Association \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umluniassoc{A}{B}
\end{tikzpicture} & Association Unique \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlaggreg{A}{B}
\end{tikzpicture} & Aggrégation. La classe A contient une collection de B. Lorsque A est détruite les instances de B ne sont pas détruites. \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlcompo{A}{B}
\end{tikzpicture} & Composition. La classe A contient une collection de B. Lorsque A est détruite les instances de B sont également détruites. \\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlinherit{A}{B}
\end{tikzpicture} & Héritage. La classe A hérite de B. On dit que A et un B.\\
\begin{tikzpicture}
\umlemptyclass{A}
\umlemptyclass[x=3]{B}
\umlimpl{A}{B}
\end{tikzpicture} & Implémentation/Réalisation \\
\end{tabularx}

\section*{Gestion d'erreurs OOP}
\begin{description}
\item[Exception] Objet lancé en cas d'erreur, interrompt l'exécution normale
\item[try-catch] Bloc de gestion des exceptions
\item[throw] Lance une exception
\item[std::exception] Classe de base pour les exceptions standard
\item[Exception safety] Garanties sur l'état des objets en cas d'exception
\end{description}

\section*{Principes modernes}
\begin{description}
\item[RAII] Resource Acquisition Is Initialization - acquérir les ressources dans le constructeur, les libérer dans le destructeur
\item[Rule of 3/5/0] Si une classe définit destructeur, constructeur de copie ou opérateur d'assignation, elle doit probablement définir les trois (ou cinq avec move)
\item[Has-a vs Is-a] Composition (Has-a) souvent préférable à l'héritage (Is-a) pour la flexibilité
\item[Smart pointers] \texttt{unique\_ptr}, \texttt{shared\_ptr}, \texttt{weak\_ptr} pour la gestion automatique de la mémoire
\item[Move semantics] Optimisation des transferts de ressources (C++11)
\item[auto] Déduction automatique de type
\item[Lambda] Fonctions anonymes et closures
\item[Range-based for] Itération simplifiée sur conteneurs
\end{description}

\section*{Design Patterns essentiels}
\begin{description}
\item[Singleton] Une seule instance de classe, accès global contrôlé
\item[Factory] Création d'objets sans exposer la logique d'instanciation
\item[Abstract Factory] Familles d'objets liés sans spécifier leurs classes
\item[Observer] Notification automatique des changements d'état
\item[Strategy] Encapsule des algorithmes et permet leur interchangeabilité
\item[Template Method] Définit le squelette d'un algorithme, sous-classes implémentent les étapes
\item[Decorator] Attache dynamiquement des responsabilités supplémentaires
\item[Command] Encapsule une requête comme un objet
\item[Adapter] Permet à des classes incompatibles de collaborer
\item[Facade] Interface simplifiée pour un sous-système complexe
\end{description}

\subsection*{Observer}
\begin{lstlisting}[language=C++]
struct IObserver {
    virtual void update() = 0; };
class Subject {
    vector<IObserver*> observers;
  public:
    void attach(IObserver* obs) { observers.push_back(obs); }
    void notify() { for (auto obs : observers) obs->update(); }
};
class ConcreteObserver : public IObserver {
    void update() override { /* ... */ } };
\end{lstlisting}

\subsection*{Strategy}
\begin{lstlisting}[language=C++]
struct IStrategy {
    virtual void execute() = 0; };
struct ConcreteStrategyA : public IStrategy {
    void execute() override { /* ... */ } };
struct ConcreteStrategyB : public IStrategy {
    void execute() override { /* ... */ } };
class Context {
    IStrategy* strategy;
  public:
    void setStrategy(IStrategy* s) { strategy = s; }
    void perform() { strategy->execute(); } };
\end{lstlisting}

\section*{Concepts avancés}
\begin{description}
\item[Inversion de contrôle] Le contrôle est transféré à un framework externe
\item[Injection de dépendance] Fourniture des dépendances depuis l'extérieur
\item[Composition over inheritance] Préférer la composition à l'héritage
\item[Law of Demeter] Un objet ne devrait communiquer qu'avec ses "amis" immédiats
\item[GRASP] Guidelines pour l'attribution des responsabilités (General Responsibility Assignment Software Patterns)
\item[Tell don't ask] Dire aux objets ce qu'ils doivent faire plutôt que demander leur état
\end{description}

\section*{Test et qualité OOP}
\begin{description}
\item[Unit testing] Test d'une classe ou méthode isolée
\item[Mock objects] Objets simulés pour isoler les tests
\item[Test fixtures] Environnement de test standardisé
\item[TDD] Test-Driven Development - écrire les tests avant le code
\item[Refactoring] Amélioration du code sans changer le comportement
\item[Code coverage] Mesure du pourcentage de code testé
\end{description}

\section*{SFINAE}
SFINAE (Substitution Failure Is Not An Error) est un principe en C++ qui permet de sélectionner des surcharges de fonctions ou des spécialisations de templates en fonction de la validité des types substitués. Si la substitution d'un type dans une expression de template échoue, cela n'est pas considéré comme une erreur de compilation, mais plutôt comme une indication que cette surcharge ou spécialisation n'est pas applicable. Cela permet de créer des fonctions ou des classes génériques qui s'adaptent automatiquement aux types fournis, en excluant les options non valides.

Exemple...

\section*{CRTP}
Le CRTP (Curiously Recurring Template Pattern) est un idiome de programmation en C++ qui utilise des templates pour permettre à une classe dérivée de référencer sa propre classe de base.

\begin{lstlisting}[language=C++]
template <typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
    void implementation() { // Comportement par défaut}
};
class Derived : public Base<Derived> {
public:
    void implementation() { // Comportement spécifique }
};
\end{lstlisting}

\section*{PIMPLE}
Le pattern PIMPLE (Private Implementation) est une technique de conception en C++ qui consiste à séparer l'interface publique d'une classe de son implémentation privée.

\begin{lstlisting}[language=C++]
// Fichier .h
class MyClass {
  class Impl; // Déclaration anticipée de la classe d'implémentation
  Impl* pImpl; // Pointeur vers l'implémentation privée
public:
  void publicMethod();
};
// Fichier .cpp
class MyClass::Impl {
public:
  void privateMethod() { /* ... */ }
};
void MyClass::publicMethod() {
  pImpl->privateMethod(); // Utilisation de la méthode privée
}
\end{lstlisting}

% \section*{Modèle de classes}
% \begin{center}
% \resizebox{\columnwidth}{!}{%
% \begin{tikzpicture}
% \begin{umlpackage}{p}
% \begin{umlpackage}{sp1}
% \umlclass[template=T]{A}{
%   n : uint \\ t : float
% }{}
% \umlclass[y=-3]{B}{
%   d : double
% }{
%   \umlvirt{setB(b : B) : void} \\ getB() : B}
% \end{umlpackage}
% \begin{umlpackage}[x=10,y=-6]{sp2}
% \umlinterface{C}{
%   n : uint \\ s : string
% }{}
% \end{umlpackage}
% \umlclass[x=2,y=-10]{D}{
%   n : uint
%   }{}
% \end{umlpackage}

% \umlassoc[geometry=-|-, arg1=tata, mult1=*, pos1=0.3, arg2=toto, mult2=1, pos2=2.9, align2=left]{C}{B}
% \umlunicompo[geometry=-|, arg=titi, mult=*, pos=1.7, stereo=vector]{D}{C}
% \umlimport[geometry=|-, anchors=90 and 50, name=import]{sp2}{sp1}
% \umlaggreg[arg=tutu, mult=1, pos=0.8, angle1=30, angle2=60, loopsize=2cm]{D}{D}
% \umlinherit[geometry=-|]{D}{B}
% \umlnote[x=2.5,y=-6, width=3cm]{B}{Je suis une note qui concerne la classe B}
% \umlnote[x=7.5,y=-2]{import-2}{Je suis une note qui concerne la relation d'import}
% \end{tikzpicture}
% }
% \end{center}

\end{multicols*}
\end{document}
